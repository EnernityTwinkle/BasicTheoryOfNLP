动态规划解题框架：

明确状态->定义dp数组的含义->明确选择->明确base case

## 求一个字符串的最长回文子串的长度

思路：给定一个字符串$A$,要找到最长回文子串，可以通过计算任意两个下标i和j（i<=j）构成的子串$A[i:j+1]$是否是回文子串，然后选择长度最长的回文子串即可。在这个过程中，下标i和j的组合复杂度是$O(n^2)$,然后计算下标i和j是否是回文子串的时间复杂度是$O(n)$,所以总的时间复杂度是$O(n^3)$

采用动态规划方法，我们可以省去计算下标i和j是否是回文子串的时间，递推公式简化为（需要注意i和j的边界条件）：
$$ dp[i][j]=
\left\{\begin{matrix}
j - i + 1&if(A[i]==A[j] \&\& dp[i+1][j-1] != 0)\\ 
0&others
\end{matrix}\right. $$
表示i和j子串是否是回文子串依赖于其中间的子串是否是回文子串，如果是，$dp[i][j]=j-i+1$,否则$dp[i][j]=0$,最后选择最长的长度即可。这种方式的时间复杂度为$O(n^2)$

另有Manacher算法来解决最长回文子串长度的问题，时间复杂度为$O(n)$


## 求两个字符串的最长公共子序列的长度
最长公共子序列是不一定连续的。

思路：dp[i][j]表示以string1[i]和string2[j]为结束下标的最长公共子序列的长度，如果string1[i]==string2[j]，那么dp[i][j] = dp[i - 1][j - 1] + 1；否则dp[i][j] = max{dp[i][j - 1], dp[i - 1][j]}。


## 求两个字符串的最长公共子串的长度
子串是连续的。

思路：dp[i][j]表示以string1[i]和string2[j]为结束的最长公共子串的长度，如果string1[i]==string2[j]，那么dp[i][j]=dp[i - 1][j - 1] + 1，否则等于0（因为最后两个不相同，不会形成公共子串）。在填充dp数组的过程中，需要记录下最长的长度和下标。

## 两个字符串的最短编辑距离
1.动态规划：dp[i][j]表示word1的前i个字符编辑成word2的前j个字符需要的最小操作数

2.初始状态：dp[i][0] = i，i次删除；dp[0][i] = i，i次插入

3.过渡公式：

当i字符等于j字符时：dp[i][j] = dp[i-1][j-1]，不需要额外操作

当i字符不等于j字符时：dp[i][j] = Math.min(insert, delete, replace)

int insert = dp[i][j-1] + 1; i个编辑成j-1个字符，再插入一个j

int delete = dp[i-1][j] + 1; i-1个编辑成j个字母，再删除一个i

int replace = dp[i-1][j-1] + 1; i-1个编辑成j-1个字母，再将i替换成j
